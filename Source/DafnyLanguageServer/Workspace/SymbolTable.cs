using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using IntervalTree;
using Microsoft.Boogie;
using Microsoft.Dafny.LanguageServer.Language;
using OmniSharp.Extensions.LanguageServer.Protocol;
using OmniSharp.Extensions.LanguageServer.Protocol.Models;
using Range = OmniSharp.Extensions.LanguageServer.Protocol.Models.Range;

namespace Microsoft.Dafny.LanguageServer.Workspace;

public class SymbolTable {

  public static SymbolTable Empty() {
    return new SymbolTable();
  }

  private SymbolTable() {
    DeclarationToUsages = ImmutableDictionary<IDeclarationOrUsage, ISet<IDeclarationOrUsage>>.Empty;
    UsageToDeclaration = ImmutableDictionary<IDeclarationOrUsage, IDeclarationOrUsage>.Empty;
    Definitions = ImmutableList<ISymbol>.Empty;
  }

  public SymbolTable(IReadOnlyList<(IDeclarationOrUsage usage, IDeclarationOrUsage declaration)> usages, ImmutableList<ISymbol> definitions) {
    var safeUsages1 = usages.Where(k => k.usage.NameToken.Uri != null).ToImmutableList();
    var safeUsages = usages.Where(k => k.usage.NameToken.Uri != null && k.declaration.NameToken.Uri != null).ToImmutableList();

    var usageDeclarations = safeUsages1.Select(k => KeyValuePair.Create(k.usage, k.declaration));
    var selfDeclarations = safeUsages1.Select(k => KeyValuePair.Create(k.declaration, k.declaration));
    UsageToDeclaration = usageDeclarations.Concat(selfDeclarations).DistinctBy(pair => pair.Key).ToImmutableDictionary();

    DeclarationToUsages = safeUsages1.GroupBy(u => u.declaration).ToImmutableDictionary(
      g => g.Key,
      g => (ISet<IDeclarationOrUsage>)g.Select(k => k.usage).ToHashSet());

    Definitions = definitions;

    var symbols = safeUsages.Select(u => u.declaration).
      Concat(safeUsages.Select(u => u.usage)).
      Where(s => !AutoGeneratedToken.Is(s.NameToken));
    var symbolsByFile = symbols.GroupBy(s => s.NameToken.Uri);
    foreach (var symbolsForFile in symbolsByFile) {
      var nodePositions = new IntervalTree<Position, IDeclarationOrUsage>();
      this.nodePositions.Add(symbolsForFile.Key, nodePositions);
      foreach (var symbolForFile in symbolsForFile) {
        var range = symbolForFile.NameToken.GetLspRange();
        nodePositions.Add(range.Start, range.End, symbolForFile);
      }
    }
  }

  private readonly Dictionary<Uri, IIntervalTree<Position, IDeclarationOrUsage>> nodePositions = new();

  /// <summary>
  /// Maps each symbol declaration to itself, and each symbol usage to the symbol's declaration.
  /// </summary>
  public ImmutableDictionary<IDeclarationOrUsage, IDeclarationOrUsage> UsageToDeclaration { get; }

  /// <summary>
  /// Maps each symbol declaration to usages of the symbol, not including the declaration itself.
  /// </summary>
  public ImmutableDictionary<IDeclarationOrUsage, ISet<IDeclarationOrUsage>> DeclarationToUsages { get; }

  /// <summary>
  ///  A list of all definitions, such as methods, classes, functions, etc., used for workspace-wide symbol
  /// lookup.
  /// </summary>
  public ImmutableList<ISymbol> Definitions { get; }

  public ISet<Location> GetUsages(Uri uri, Position position) {
    if (nodePositions.TryGetValue(uri, out var forFile)) {
      return forFile.Query(position).
        SelectMany(node => DeclarationToUsages.GetOrDefault(node, () => (ISet<IDeclarationOrUsage>)new HashSet<IDeclarationOrUsage>())).
        Select(u => new Location { Uri = u.NameToken.Filepath, Range = u.NameToken.GetLspRange() }).ToHashSet();
    }
    return Sets.Empty<Location>();
  }

  public Location? GetDeclaration(Uri uri, Position position) {
    var node = GetNode(uri, position);
    return node == null ? null : NodeToLocation(node);
  }

  internal static Location NodeToLocation(IDeclarationOrUsage node) {
    return new Location {
      Uri = DocumentUri.From(node.NameToken.Uri),
      Range = node.NameToken.GetLspRange()
    };
  }

  public IDeclarationOrUsage? GetNode(Uri uri, Position position) {
    if (!nodePositions.TryGetValue(uri, out var forFile)) {
      return null;
    }
    return forFile.Query(position)
      .Select(node => UsageToDeclaration.GetOrDefault(node, () => (IDeclarationOrUsage?)null))
      .FirstOrDefault(x => x != null);
  }
}
