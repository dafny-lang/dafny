using System.Diagnostics.Contracts;
using System.IO;

namespace Microsoft.Dafny;

public static class TokenExtensions {
  
  
  public static DafnyRange ToDafnyRange(this TokenRange node, bool includeTrailingWhitespace = false) {
    var startLine = node.Start.line - 1;
    var startColumn = node.Start.col - 1;
    int whitespaceOffset = 0;
    if (includeTrailingWhitespace) {
      string trivia = (node.End ?? node.Start).TrailingTrivia;
      // Don't want to remove newlines or comments -- just spaces and tabs
      while (whitespaceOffset < trivia.Length && (trivia[whitespaceOffset] == ' ' || trivia[whitespaceOffset] == '\t')) {
        whitespaceOffset++;
      }
    }

    var endColumn = (node.End == null ? node.Start.col : node.End.col + node.End.val.Length) + whitespaceOffset - 1;
    var endLine = node.End == null ? startLine : node.End.line - 1;
    return new DafnyRange(
      new DafnyPosition(startLine, startColumn),
      new DafnyPosition(endLine, endColumn));
  }
  
  public static DafnyRange ToDafnyRange(this INode node, bool includeTrailingWhitespace = false) {
    var startLine = node.StartToken.line - 1;
    var startColumn = node.StartToken.col - 1;
    var endLine = node.EndToken.line - 1;
    int whitespaceOffset = 0;
    if (includeTrailingWhitespace) {
      string trivia = node.EndToken.TrailingTrivia;
      // Don't want to remove newlines or comments -- just spaces and tabs
      while (whitespaceOffset < trivia.Length && (trivia[whitespaceOffset] == ' ' || trivia[whitespaceOffset] == '\t')) {
        whitespaceOffset++;
      }
    }

    var inclusiveEnd = true; // node.InclusiveEnd
    var endColumn = node.EndToken.col + (inclusiveEnd ? node.EndToken.val.Length : 0) + whitespaceOffset - 1;
    return new DafnyRange(
      new DafnyPosition(startLine, startColumn),
      new DafnyPosition(endLine, endColumn));
  }
  
  // public static DafnyRange ToDafnyRange(this Token origin, bool includeTrailingWhitespace = false) {
  //   var startLine = origin.line - 1;
  //   var startColumn = origin.col - 1;
  //   var endLine = origin.line - 1;
  //   int whitespaceOffset = 0;
  //   if (includeTrailingWhitespace) {
  //     string trivia = origin.TrailingTrivia;
  //     // Don't want to remove newlines or comments -- just spaces and tabs
  //     while (whitespaceOffset < trivia.Length && (trivia[whitespaceOffset] == ' ' || trivia[whitespaceOffset] == '\t')) {
  //       whitespaceOffset++;
  //     }
  //   }
  //
  //   var endColumn = origin.col + (origin.InclusiveEnd ? origin.EndToken.val.Length : 0) + whitespaceOffset - 1;
  //   return new DafnyRange(
  //     new DafnyPosition(startLine, startColumn),
  //     new DafnyPosition(endLine, endColumn));
  // }
  //
  // public static DafnyRange ToDafnyRange(this IOrigin origin, bool includeTrailingWhitespace = false) {
  //   var startLine = origin.StartToken.line - 1;
  //   var startColumn = origin.StartToken.col - 1;
  //   var endLine = origin.EndToken.line - 1;
  //   int whitespaceOffset = 0;
  //   if (includeTrailingWhitespace) {
  //     string trivia = origin.EndToken.TrailingTrivia;
  //     // Don't want to remove newlines or comments -- just spaces and tabs
  //     while (whitespaceOffset < trivia.Length && (trivia[whitespaceOffset] == ' ' || trivia[whitespaceOffset] == '\t')) {
  //       whitespaceOffset++;
  //     }
  //   }
  //
  //   var endColumn = origin.EndToken.col + (origin.InclusiveEnd ? origin.EndToken.val.Length : 0) + whitespaceOffset - 1;
  //   return new DafnyRange(
  //     new DafnyPosition(startLine, startColumn),
  //     new DafnyPosition(endLine, endColumn));
  // }

  public static IOrigin MakeAutoGenerated(this IOrigin origin) {
    return new AutoGeneratedOrigin(origin);
  }

  public static IOrigin MakeRefined(this IOrigin origin, ModuleDefinition module) {
    return new RefinementOrigin(origin, module);
  }

  public static bool Contains(this TokenRange container, IOrigin otherToken) {
    return container.Start.Uri == otherToken.Uri &&
           container.Start.pos <= otherToken.pos &&
           (container.End == null || otherToken.pos <= container.End.pos);
  }

  public static bool Intersects(this TokenRange origin, IOrigin other) {
    return !(other.pos + other.EndToken.val.Length <= origin.Start.pos
             || origin.End.pos + origin.End.val.Length <= other.StartToken.pos);
  }

  public static string PrintOriginal(this IOrigin origin) {
    // TODO only call on INode
    return origin.EntireRange.PrintOriginal();
  }

  public static bool IsSet(this IOrigin token) => token.Uri != null;

  public static string TokenToString(this IOrigin tok, DafnyOptions options) {
    if (ReferenceEquals(tok, Token.Cli)) {
      return "CLI";
    }

    if (tok.Uri == null) {
      return $"({tok.line},{tok.col - 1})";
    }

    var currentDirectory = Directory.GetCurrentDirectory();
    string filename = tok.Uri.Scheme switch {
      "stdin" => "<stdin>",
      "transcript" => Path.GetFileName(tok.Filepath),
      _ => options.UseBaseNameForFileName
        ? Path.GetFileName(tok.Filepath)
        : (tok.Filepath.StartsWith(currentDirectory) ? Path.GetRelativePath(currentDirectory, tok.Filepath) : tok.Filepath)
    };

    return $"{filename}({tok.line},{tok.col - 1})";
  }
}

/// <summary>
/// A token wrapper used to produce better type checking errors
/// for quantified variables. See QuantifierVar.ExtractSingleRange()
/// </summary>
public class QuantifiedVariableDomainOrigin : OriginWrapper {
  public QuantifiedVariableDomainOrigin(IOrigin wrappedOrigin)
    : base(wrappedOrigin) {
    Contract.Requires(wrappedOrigin != null);
  }

  public override string val {
    get { return WrappedOrigin.val; }
    set { WrappedOrigin.val = value; }
  }
}

/// <summary>
/// A token wrapper used to produce better type checking errors
/// for quantified variables. See QuantifierVar.ExtractSingleRange()
/// </summary>
public class QuantifiedVariableRangeOrigin : OriginWrapper {
  public QuantifiedVariableRangeOrigin(IOrigin wrappedOrigin)
    : base(wrappedOrigin) {
    Contract.Requires(wrappedOrigin != null);
  }

  public override string val {
    get { return WrappedOrigin.val; }
    set { WrappedOrigin.val = value; }
  }
}
