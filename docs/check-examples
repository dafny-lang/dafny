#! /usr/bin/env bash

## This file accepts a couple options (before any files)
## and then iterates over the remaining command-line arguments as files.
## The options are
##    -d <name>  -- here <name> is a default command (see below)
##    -l <lang>  -- <lang> is the name of a language to use as default
##                   (a language name as used with ```, e.g.,
##                   dafny, java, text, cli, ...)
##    -x <int>   -- <int> is an (non-negative) integer literal giving 
##                  a default exit code
##    -m         -- compare against error messages in headings
## It expects a file to be in github markdown format.
##
## It extracts each block of text that is between lines bounded by a pair
## of lines beginning with ```. The opening ``` is typically follwed
## immediately (without whitespace) by a language identifier. If no
## language identifier is present, the default language specified by the -l
## option is used; if there is no such option, an error is output.
## The extracted text is placed in a temporary file.
##
## If the text blocks are not in matching pairs of ``` markers or if 
## markers other than 3 backticks are used, the script will fail -- it is
## not robust against such non-well-formedness.
## Also, the backticks must start the line without leading whitespace and 
## the language identifier must follow without whitespace.
##
## Each block of extracted text is tested by applying a command.
## The command is stated by including in the ```dafny line the string
## <!-- command --> where in that HTML comment string, the 'command' is one
## of the commands below. If there is no such HTML comment, then the default
## command given by an option is used; if there is no such option, an error
## message is issued.
##
## In the description of behavior below, if -m has been given as an option
## then the comparison of the output line containing 'Error' is against the
## error message as recorded in the '##' heading just before the test
##
## Commands (here $F is the name of a file containing the dafny source code
## under test):
##   %no-check : do nothing
##   %check-verify <expect> or
##   %check-verify-warn : runs the command 
##              "dafny verify --useBaseNameForFileName $F" and checks 
##              (1) if <expect> is absent then the exit code is 0 and
##                  the output is just a success message
##              (2) if <expect> is non-empty. then the exit code is 4 and
##                  the actual output matches the content of the file <expect>
##                  if the command is %check-verify-warn, the exit code is 0
##   %check-resolve <expect> : runs the command
##              "dafny resolve --useBaseNameForFileName $F" and checks
##              (1) if <expect> is absent then the exit code is 0 and
##                  the output is just a success message
##              (2) if <expect> is non-empty. then the exit code is 2 and
##                  the actual output matches the content of the file <expect>
##   %check-translate <expect> : runs the command
##              "dafny translate --useBaseNameForFileName $F" and checks
##              (1) if <expect> is absent then the exit code is 0 and
##                  the output is just a success message
##              (2) if <expect> is non-empty. then the exit code is r32 and
##                  the actual output matches the content of the file <expect>
##   %check-run <expect> : runs the command
##              "dafny run --useBaseNameForFileName $F" and, 
##              if <expect> is present, then check that the output matches the
##              content of the file names <expect> and that the exit code is 0

dir=$(dirname "${BASH_SOURCE[0]}")
dafny="$dir/../Scripts/dafny"

defaultCommand=
defaultExit=
defaultLang=
useHeadings=0

while getopts 'md:x:l:' opt; do
  case "$opt" in
    "d") defaultCommand="$OPTARG";;
    "x") defaultExit="$OPTARG";;
    "l") defaultLang="$OPTARG";;
    "m") useHeadings=1
  esac
done
shift $(($OPTIND - 1))

## Temporary file
text=text.dfy

## Tracks if there have been any failures
ANYFAIL=0

## Loop over all remaining command-line arguments
for file in $@ ; do
dir=$(dirname "$file")

## Whether this file fails
FAIL=0
## line number
n=0
## if inblock==1 we are in a ```-delimited block
inblock=0

msg=
checkingErrors=1
## Read and process each line of the file.  The file is input on stdin 
## by redirection after the 'done' corresponding to this while-do
use=
command=
expect=
options=
default=0
while IFS= read -r line
do 
  let n++

  ## For header lines, extract the error message from
  ## the header text (everything but the initial ##[ ]* )
  ( echo "$line" | grep -E -e '[#][#] ' > /dev/null ) \
   && msg=`echo "$line" | sed -E -e 's/^##[ ]*//' -e 's/_[a-z]+_/.*/g'`

  ## Check for the test command information
  echo "$line" | grep '^[ ]*<!-- [ ]*%' > /dev/null
  if [ "$?" == "0" ]; then 
      ##echo COMMAND "$line"
      contents=( `echo "$line" | sed -e 's/[^<]*<!--//' -e 's/-->//'` )
      command=${contents[0]}
      expect=${contents[1]}
      if [ "$expect" == "%use" -o "$expect" == "%options" ]; then
        expect=
      fi
      options=
      ( echo "$line" | grep -e '%options' > /dev/null ) \
          && options=( `echo "$line" | sed -e 's/^.*%options//' -e 's/-->//'` )
      if [ "${contents[1]}" == "%use" ]; then
        use=${contents[2]}
      fi
      if [ "${contents[2]}" == "%use" ]; then
        use=${contents[3]}
      fi
      if [ -z "$command" ]; then
        command="$defaultCommand"
        if [ -z "$command" ]; then
          echo "NO COMMAND GIVEN $n $line"
          FAIL=1
        fi
      fi
      echo "$line" | grep -e '%default' > /dev/null
      if [ "$?" == "0" ]; then default=1; fi
  fi
  ## Check for the marker
  echo "$line" | grep -e '^[ ]*[`][`][`]' > /dev/null 
  if [ "$?" == "0" ]; then
    if [ "$inblock" == "0" ]; then
      ## get language
      lang=`echo "$line" | sed -e 's/^[ ]*\`\`\`[\`]*//' -e 's/[ ]*$//'`
      if [ -z "$lang" ]; then
        lang=$defaultLang
        if [ -z "$lang" ]; then
          echo NO LANGUAGE LABEL $n "$line"
          FAIL=1
        fi
      fi

      inblock=1
      rm -f $text
      touch $text
    else
      ## End of backtick block, so check the text
      inblock=0
      if [ -n "$use" ]; then
        ##echo " " USING $use
        cat "$use" >> $text
      fi
      echo $line | grep '%save' > /dev/null
      if [ "$?" == "0" ]; then
         rest=( `echo $line | sed -e 's/^[^%]*%save//'` )
         save=${rest[0]}
         ##echo " SAVING" $save
         cp $text $save
      fi
      if [ "$lang" == "dafny" -o "$lang" == "cli" ]; then
        echo TESTING $n $file "$command" $expect
      fi
      if [ "$command" == "%no-check" ]; then
        echo -n ""
      elif [ "$command" == "%check-verify" -o "$command" == "%check-verify-warn" -o "$command" == "%check-resolve"  -o "$command" == "%check-run" -o "$command" == "%check-translate" ]; then
        capture=1
        if [ "$command" == "%check-verify" ]; then
          com=verify
          ec=4
        elif [ "$command" == "%check-verify-warn" ]; then
          com=verify
          ec=0
        elif [ "$command" == "%check-resolve" ]; then
          com=resolve
          ec=2
        elif [ "$command" == "%check-translate" ]; then
          com=translate
          ec=3
        elif [ "$command" == "%check-run" ]; then
          com=run
          ec=0
        fi
        if [ "$lang" != "dafny" ]; then
          echo EXPECTED A dafny BLOCK, NOT $lang
          FAIL=1
        else
          if [ "$capture" == "2" ]; then
            "$dafny" $com --useBaseNameForFileName $options $text 2> actual > /dev/null
          else
            "$dafny" $com --useBaseNameForFileName $options $text > actual
          fi
          actualec=$?
          if [ "$useHeadings" == "1" ]; then
            if [ "$actualec" != "$ec" ]; then
              echo EXPECTED EXIT CODE $ec, got $actualec
              FAIL=1
            fi
            act=`cat actual | grep Error | sed -e 's/^[^:]*: //'`
            dif=`echo $act | sed -e "s/$msg//"`
            if [ -n "$dif" ] ; then
               echo NO MATCH "$msg" VS "$act"
               FAIL=1
            fi
            msg=
          elif [ -z "$expect" ]; then
            if [ "$actualec" != "0" ]; then
              echo "TEST FAILED" $file line $n  $command $expect
              cat $text
              cat actual
              FAIL=1
            fi
            if [ `cat actual | wc -l ` != "2" ]; then
              echo ACTUAL ERROR OUTPUT BUT NONE EXPECTED
              cat actual
              FAIL=1
            fi
          else
            if [ "$actualec" != "$ec" ]; then
              echo EXPECTED EXIT CODE $ec, got $actualec
              FAIL=1
            fi
            if [ -e "$dir/$expect" ]; then
              diff actual "$dir/$expect"
              if [ "$?" != "0" ]; then
                FAIL=1
                echo Actual output differs from expected
                echo "TEST FAILED" $file line $n  $command $expect
                cat $text
                cat actual
              fi
            else
              echo EXPECT FILE $expect DOES NOT EXIST
              cat actual
              FAIL=1
            fi
          fi
        fi
      elif [ "$command" == "%check-cli" ]; then
        if [ "$lang" != "bash" ]; then
          echo EXPECTED A bash BLOCK, NOT $lang
          FAIL=1
        else
          . $text > actual
          ec=$?
          if [ "$ec" != "1" ]; then
             echo EXPECTED EXIT CODE OF 1, GOT $ec
             FAIL=1
          else
            act=`cat actual`
	    dif=`echo $act | sed -e "s/$msg//"`
            if [ -n "$dif" ]; then
              echo ACTUAL OUTPUT DOES NOT MATCH EXPECTED: "$msg" VS "$act"
              FAIL=1
            fi
          fi
        fi
      elif [ "$command" == "%check-error" ]; then
        "$dafny" resolve -useBaseNameForFileName $text | head -1 | sed -e 's/[^:]*: //' > actual
        act=`cat actual`
	dif=`echo "$act" | sed -e "s/$msg//"`
        if [ -n "$dif" ] ; then
           echo NO MATCH "$msg" VS "$act"
           FAIL=1
        fi
        msg=
      elif [ "$lang" == "dafny" ]; then
         echo UNKNOWN TEST COMMAND $command
         FAIL=1
      fi
      if [ "$default" == "0" ]; then
        use=
        command=
        expect=
        options=
      fi
    fi
  elif [ "$inblock" == "1" ]; then
    ## If in a backtick block, save the text to the temporary file
    echo "$line" | sed -e 's/^[ ]*\.\.\./   /' >> $text
  fi
done < $file
rm -rf *.tmp

if [ "$inblock" == "1" ]; then
  echo UNCLOSED BACKTICK BLOCK
  FAIL=1
fi

if [ "$FAIL" == "1" ] ; then 
  echo Test Failure: $file
  ANYFAIL=1
fi

rm -f actual $text *.tmp
done
exit $ANYFAIL
